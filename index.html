<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schedule 1 - Customer List</title>
    <!-- Pico CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Schedule 1 - Customer List</h1>
        <div class="theme-switcher">
          <button id="themeToggle">Toggle Theme</button>
        </div>
      </header>

      <main>
        <!-- Filter Controls -->
        <div class="filters-container">
          <div class="filter-column">
            <fieldset>
              <legend>
                <details class="filter-accordion" open>
                  <summary>Filter by Area <span class="filter-count"></span></summary>
                  <div id="areaFilters" class="checkbox-group">
                    <!-- Will be populated dynamically -->
                  </div>
                </details>
              </legend>
            </fieldset>
          </div>

          <div class="filter-column">
            <fieldset>
              <legend>
                <details class="filter-accordion">
                  <summary>Filter by Standards <span class="filter-count"></span></summary>
                  <div id="standardsFilters" class="checkbox-group">
                    <!-- Will be populated dynamically -->
                  </div>
                </details>
              </legend>
            </fieldset>
          </div>

          <div class="filter-column">
            <fieldset>
              <legend>
                <details class="filter-accordion">
                  <summary>Filter by Favorites <span class="filter-count"></span></summary>
                  <div id="favoritesFilters" class="checkbox-group">
                    <!-- Will be populated dynamically -->
                  </div>
                </details>
              </legend>
            </fieldset>
          </div>
        </div>

        <div class="content-area">
          <!-- Name Search -->
          <div class="search-wrapper">
            <label for="nameSearch">Search by Name:</label>
            <input type="text" id="nameSearch" placeholder="Type a name...">
            <div class="results-count">
              Showing <span id="filteredCount">0</span> of <span id="totalCount">0</span> customers
            </div>
          </div>

          <!-- Results -->
          <div class="cards-grid" id="results">
            <!-- Results will be populated here -->
          </div>
        </div>
      </main>

      <footer>
        <p>Schedule 1 Customer Profiles - 2023</p>
      </footer>
    </div>

    <script>
      let rawData = [];
      let favoriteColors = {};
      let filteredData = []; // Cache for filtered data
      let debounceTimer; // For debouncing filter changes

      // Active filters
      let activeFilters = {
        areas: [],
        standards: [],
        favorites: [],
        nameSearch: ''
      };

      // Theme toggling
      document.getElementById('themeToggle').addEventListener('click', () => {
        document.documentElement.setAttribute('data-theme', 
          document.documentElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light');
      });

      // Fetch data on page load
      window.addEventListener('DOMContentLoaded', async () => {
        // Set initial theme based on user preference
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        document.documentElement.setAttribute('data-theme', prefersDark ? 'dark' : 'light');
        
        try {
          // Load data and colors
          const [peopleData, colorsData] = await Promise.all([
            fetch('data.json').then(res => res.json()),
            fetch('colors.json').then(res => res.json())
          ]);
          
          rawData = peopleData;
          favoriteColors = colorsData;
          filteredData = [...rawData];

          // Extract unique values for filters
          const areas = [...new Set(rawData.map(person => person.Area))];
          const standards = [...new Set(rawData.map(person => person.Standards))];
          const favorites = [...new Set(rawData.flatMap(person => person.Favorites))];
          
          // Update counts
          document.getElementById('totalCount').textContent = rawData.length;
          document.getElementById('filteredCount').textContent = filteredData.length;
          
          // Create filter checkboxes
          createCategoryCheckboxes('area', areas);
          createCategoryCheckboxes('standards', standards);
          createCategoryCheckboxes('favorites', favorites);
          
          // Render results after a short delay to ensure smooth UI
          setTimeout(() => {
            renderResults(filteredData);
          }, 100);

          // Open all filter accordions by default
          document.querySelectorAll('.filter-accordion').forEach(accordion => {
            accordion.setAttribute('open', '');
          });
        } catch (err) {
          console.error('Error loading data:', err);
          const resultsContainer = document.getElementById('results');
          resultsContainer.innerHTML = '<div class="no-results">Failed to load data. Please try refreshing the page.</div>';
        }

        // Set up filter listeners
        document.getElementById('nameSearch').addEventListener('input', debounceFilterChange);
      });

      // Debounce function to prevent rapid re-rendering
      function debounceFilterChange() {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(filterData, 300);
      }
      
      // Create filter checkboxes
      function createCategoryCheckboxes(category, items) {
        const container = document.getElementById(`${category}Filters`);
        container.innerHTML = '';
        
        // Sort items alphabetically
        const sortedItems = [...items].sort();
        
        sortedItems.forEach(item => {
          const countByFilter = getCountByFilter(category, item);
          
          // Create wrapper div
          const div = document.createElement('div');
          div.className = 'checkbox-item';
          
          // Create checkbox input
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.id = `${category}-${item.replace(/\s+/g, '-')}`;
          input.value = item;
          
          // Add change event listener
          input.addEventListener('change', (e) => {
            const filterType = category === 'area' ? 'areas' : 
                              category === 'standards' ? 'standards' : 
                              category === 'favorites' ? 'favorites' : '';
            
            if (e.target.checked) {
              if (!activeFilters[filterType].includes(item)) {
                activeFilters[filterType].push(item);
              }
            } else {
              activeFilters[filterType] = activeFilters[filterType].filter(f => f !== item);
            }
            
            filterData();
          });
          
          // Create label
          const label = document.createElement('label');
          label.htmlFor = input.id;
          
          // Create text span for the label (without count)
          const textSpan = document.createElement('span');
          textSpan.className = 'favorite-text';
          textSpan.textContent = item;
          
          // Style favorites with their colors
          if (category === 'favorites') {
            if (favoriteColors[item]) {
              const color = favoriteColors[item];
              textSpan.style.backgroundColor = color + '20';
              textSpan.style.color = favoriteColors[item];
              textSpan.style.border = `1px solid ${favoriteColors[item]}`;
            } else {
              textSpan.style.textDecoration = 'underline';
              textSpan.style.textDecorationStyle = 'wavy';
              textSpan.style.textDecorationColor = 'var(--primary)';
            }
          }
          
          // Create count text with specific class
          const countSpan = document.createElement('span');
          countSpan.className = 'count-text';
          countSpan.textContent = ` (${countByFilter})`;
          
          // Add elements to label
          label.appendChild(textSpan);
          label.appendChild(countSpan);
          
          // Add elements to container
          div.appendChild(input);
          div.appendChild(label);
          container.appendChild(div);
        });
      }
      
      // Count people matching a specific filter
      function getCountByFilter(category, value) {
        // For each filter type, we need to check a different property
        switch(category) {
          case 'area':
            return rawData.filter(person => person.Area === value).length;
          case 'standards':
            return rawData.filter(person => person.Standards === value).length;
          case 'favorites':
            return rawData.filter(person => person.Favorites.includes(value)).length;
          default:
            return 0;
        }
      }
      
      // Update the counts in the filter selection
      function updateFilterCounts() {
        // Store current search/filter state
        const nameSearch = document.getElementById('nameSearch').value.toLowerCase().trim();
        activeFilters.nameSearch = nameSearch;
        
        // Get counts with current filters applied
        const counts = {
          area: {},
          standards: {},
          favorites: {}
        };
        
        // Count what would be shown if this filter were applied
        rawData.forEach(person => {
          // Check if person matches name search
          const matchesName = !nameSearch || person.Name.toLowerCase().includes(nameSearch);
          
          // Check if person matches other active filters
          const matchesAreaFilters = activeFilters.areas.length === 0 || 
                                    activeFilters.areas.includes(person.Area);
          
          const matchesStandardsFilters = activeFilters.standards.length === 0 || 
                                         activeFilters.standards.includes(person.Standards);
          
          const matchesFavoritesFilters = activeFilters.favorites.length === 0 || 
                                         activeFilters.favorites.every(fav => person.Favorites.includes(fav));
          
          // Count for area filters
          if (matchesName && matchesStandardsFilters && matchesFavoritesFilters) {
            counts.area[person.Area] = (counts.area[person.Area] || 0) + 1;
          }
          
          // Count for standards filters
          if (matchesName && matchesAreaFilters && matchesFavoritesFilters) {
            counts.standards[person.Standards] = (counts.standards[person.Standards] || 0) + 1;
          }
          
          // Count for favorites filters (show count if adding this favorite to current selection)
          if (matchesName && matchesAreaFilters && matchesStandardsFilters) {
            // For each favorite, check how many would match with this favorite
            [...new Set(person.Favorites)].forEach(fav => {
              // For selected favorites, check if this person matches all OTHER selected favorites
              if (activeFilters.favorites.includes(fav)) {
                const otherFavorites = activeFilters.favorites.filter(f => f !== fav);
                if (otherFavorites.every(f => person.Favorites.includes(f))) {
                  counts.favorites[fav] = (counts.favorites[fav] || 0) + 1;
                }
              } else {
                // For unselected favorites, check if adding this favorite would still match
                const wouldMatch = [...activeFilters.favorites, fav].every(f => person.Favorites.includes(f));
                if (wouldMatch) {
                  counts.favorites[fav] = (counts.favorites[fav] || 0) + 1;
                }
              }
            });
          }
        });
        
        // Update the UI with counts
        updateCategoryFilterCounts('area', counts.area);
        updateCategoryFilterCounts('standards', counts.standards);
        updateCategoryFilterCounts('favorites', counts.favorites);
        
        // Update filter summary counts in headers (removed count display)
        document.querySelectorAll('.filter-count').forEach(countEl => {
          countEl.textContent = '';
        });
      }
      
      // Update counts for a specific category
      function updateCategoryFilterCounts(category, counts) {
        document.querySelectorAll(`#${category}Filters .checkbox-item`).forEach(item => {
          const checkbox = item.querySelector('input[type="checkbox"]');
          const countSpan = item.querySelector('.count-text');
          const value = checkbox.value;
          
          // Update count text
          const count = counts[value] || 0;
          countSpan.textContent = ` (${count})`;
          
          // Disable checkboxes with zero matches
          checkbox.disabled = count === 0 && !checkbox.checked;
          
          // Apply visual styling to show enabled/disabled state
          if (count === 0 && !checkbox.checked) {
            item.classList.add('no-results');
          } else {
            item.classList.remove('no-results');
          }
        });
      }

      // Filter the data based on all active filters
      function filterData() {
        // Show a loading state
        const resultsContainer = document.getElementById('results');
        resultsContainer.classList.add('filtering');
        
        // Get current name search
        activeFilters.nameSearch = document.getElementById('nameSearch').value.toLowerCase().trim();
        
        // Use requestAnimationFrame to ensure UI updates before filtering
        requestAnimationFrame(() => {
          filteredData = rawData.filter((person) => {
            // Match name search
            const matchName = !activeFilters.nameSearch || 
                             person.Name.toLowerCase().includes(activeFilters.nameSearch);
            
            // Match area (ANY of the selected areas)
            const matchArea = activeFilters.areas.length === 0 || 
                             activeFilters.areas.includes(person.Area);
            
            // Match standards (ANY of the selected standards)
            const matchStandards = activeFilters.standards.length === 0 || 
                                  activeFilters.standards.includes(person.Standards);
            
            // Match favorites (ALL of the selected favorites)
            const matchFavorites = activeFilters.favorites.length === 0 || 
                                  activeFilters.favorites.every(fav => person.Favorites.includes(fav));
            
            return matchName && matchArea && matchStandards && matchFavorites;
          });
          
          // Update the filter counts
          updateFilterCounts();
          
          // Update the results count
          document.getElementById('filteredCount').textContent = filteredData.length;
          
          // Use requestAnimationFrame to render after the DOM has been updated
          requestAnimationFrame(() => {
            renderResults(filteredData);
            resultsContainer.classList.remove('filtering');
          });
        });
      }

      async function renderResults(dataArray) {
        const container = document.getElementById('results');
        const fragment = document.createDocumentFragment();

        if (dataArray.length === 0) {
          const noResults = document.createElement('div');
          noResults.className = 'no-results';
          noResults.textContent = 'No customers match your search criteria';
          fragment.appendChild(noResults);
        } else {
          dataArray.forEach(person => {
            const card = document.createElement('article');
            card.className = 'person-card';

            const info = document.createElement('div');
            info.className = 'card-content';
            
            const heading = document.createElement('h3');
            heading.textContent = person.Name;
            info.appendChild(heading);
            
            const areaP = document.createElement('p');
            areaP.innerHTML = `<strong>Area:</strong> ${person.Area}`;
            info.appendChild(areaP);
            
            const standardsP = document.createElement('p');
            standardsP.innerHTML = `<strong>Standards:</strong> ${person.Standards}`;
            info.appendChild(standardsP);
            
            const favoritesP = document.createElement('p');
            favoritesP.innerHTML = `<strong>Favorites:</strong>`;
            
            const tagsDiv = document.createElement('div');
            tagsDiv.className = 'tags';
            
            person.Favorites.forEach(fav => {
              const tag = document.createElement('span');
              tag.className = 'tag';
              tag.textContent = fav;
              
              if (favoriteColors[fav]) {
                tag.style.backgroundColor = favoriteColors[fav];
                tag.style.color = getContrastColor(favoriteColors[fav]);
              } else {
                // Add underline style for favorites without colors
                tag.style.textDecoration = 'underline';
                tag.style.textDecorationStyle = 'wavy';
                tag.style.textDecorationColor = 'var(--primary)';
              }
              
              tagsDiv.appendChild(tag);
            });
            
            info.appendChild(favoritesP);
            info.appendChild(tagsDiv);
            card.appendChild(info);
            fragment.appendChild(card);
          });
        }

        container.innerHTML = '';
        container.appendChild(fragment);
      }
      
      // Calculate contrasting text color (black or white) based on background color
      function getContrastColor(hexColor) {
        // Remove the # if present
        hexColor = hexColor.replace('#', '');
        
        // Parse the hex color
        const r = parseInt(hexColor.substr(0, 2), 16);
        const g = parseInt(hexColor.substr(2, 2), 16);
        const b = parseInt(hexColor.substr(4, 2), 16);
        
        // Calculate luminance (perceived brightness)
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        
        // Return black for bright colors, white for dark ones
        return luminance > 0.5 ? '#000000' : '#ffffff';
      }
    </script>
  </body>
</html>
